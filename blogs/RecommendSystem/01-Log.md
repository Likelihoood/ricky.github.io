
# 埋点日志设计原则简介
---

- 日志的重要性
  - 没有日志的产品, 就是在开一架没有仪表盘的飞机,不知道产品的优化效果, 不知道用户的反馈
- Client 端日志设计的基本逻辑
  - 记录: 什么人在什么时候在什么地方用什么 App 在 App 的什么页面和区域对该区域的某个对象做了一件什么事情
    - 什么人:
    - 设备信息
    - 用户信息
      - 为保护用户信息, 一般需加密防止第三方抓包获取对商业不利信息
    - 什么时候
      - 时间信息
        - 动作发生时间
        - 日志上传时间 (不可和动作发生时间弄混)该时间通常server 端接收时也需要记录
    - 什么地方
      - IP
      - GPS 信息
      - 解析后的国家,省份,城市,地区信息
    - 什么 APP
      - App 信息
    - 在什么页面
      - 场景信息: 页面 + 区域 和 APP实现强相关
      - 上一条动作的信息,用于追踪动作路径
    - 对某个对象
      - 对象信息, 和业务强相关, 一般后台业务数据库表里存储的实体
        - 文章
        - 作者
        - 栏目
        - 视频
    - 做了一件什么事情
      - 动作的类型
        - 点击, 滑动
      - 动作的语义
        - 对不同对象, 相同的动作类型有着不一样的语义, 如同样是点击动作, 对于文章是查看详情, 对于视频是播放
      - 动作附加信息
        - 如播放时间, 访问时长等
    - 日志信息
      - 日志 ID, 唯一标识一条日志, 用于当网络问题 App 重发相同日志, 需要去重, 追踪日志问题
    - 策略算法信息
      - 后端 server 采用某一算法或策略给出推荐结果(如文章列表), 希望追踪该算法或者策略 对最终用户的行为有无提升和贬损
      - 后端 server 给出该文章列表时, 为每个文章附加
      - 信息唯一标识字符串
      - 实验 ID 等,
      - Client 端接到该信息时, 会将这个信息 并入每个和该对象相关的日志信息中
      - Client 端实现方式回严重影响该值的透传, 一般只要不穿越太多场景,都必须携带. 如果遇到其他算法信息, 就直接替换新的
- 日志类型说明
  - 曝光日志
    - 当用户将某个业务对象 滑动至屏幕可见区域,需要打曝光日志针对列表页的日志
  - 用户行为日志
    - 点击,滑动等
    - 动作对象信息, 如对象 ID, 对象类型
    - 需要记录动作语义, 比如 查看详情, 播放,评论,加入某个业务组织
  - 页面刷新日志
    - 当某个页面被加载时, 需要打印该日志
    - 用于标识某个页面被客户端加载成功
    - 有一个唯一标识的 ID, pv_id
    - 当页面被关闭, 需要打印一个 quit 日志, 记录该页面被打开的时长, 通长在记录某个文章被阅读时间非常有用
  - APP 相关日志
    - app 的加载退出, 退出时带 时长信息, 标识一次启动的用户时长
    - 和后端的API 交互信息,
      - 带一个 req_id 唯一标识一个请求,
      - 带处理时间, 可评估 API 性能
    - 视频播放信息
      - 视频的卡顿时间戳
      - 播放的唯一标识 play_id, 用于标识一个用户的某一次播放, 两次播放同一个视频, play_id 不一样
- 重要字段说明
  - req_id
    - 和后端交互一次的唯一标识
    - 一般要携带到 和这次请求获取的对象的后续用户行为日志中
      - 如首页打开时, 获取了10个文章的列表
        后续 10个文章的 曝光, 用户点击等都需要携带这个 req_id
  - pv_id
    - 页面刷新时必须更新
    - 方便计算页面 PV
  - play_id
    - 唯一标识播放的 id
    - 方便统计播放次数
  - 策略算法信息
    - 行为路径全携带, 用于追踪算法效果
- 日志重要信息整理
  - 页面区域信息
    - 头条
    - 各种列表
    - 分类页等
  - 业务实体信息整理
    - 分类
    - 文章
    - 标签
    - 作者
    - 栏目
    - 聊天室
- 日志时序性
  - 日志严格按照动作发生时间产生和发送
  - 例如app 启动行为日志序列
    - app_start: app 启动
    - api_request: 访问后端, 获取要展示的对象信息
    - 页面加载日志
    - 对象曝光日志
- 日志设计原则
  - 业务和UI 实现分离
  - 最好不要和 UI 绑定实体信息, 也就是说任何实体可以出现在任何页面和区域 方便后续扩展
  - 实现上
    - APP 开发要从框架上考虑日志实现, 不要一块一块的补丁逻辑, 防止出错
    - 日志的实现, 可以定好框架后, 一个场景一个场景的推进
- 日志传输方式
  - HTTP GET 请求,
    - 具体方式
      - 访问一个无占空间的静态资源, 如 www.test.com/log.gif
      - 日志内容以 GET 请求参数方式提交
      - 为防止参数过长, 可压缩文本串 后 上传, 后端解压
      - 检查 GET 请求结果, 失败则重试, 多次重试无法上传, 本地持久化后待网络接到后再次上传
      - 要设计上传的超时逻辑, 超过3天日志 丢弃
    - 优点
      - Client 端无状态
      - Server 端 Nginx server 接收, 简单解析后 可以直接 结构化入库
    - 缺点
      - HTTPGET 请求有参数长度限制
      - HTTP 非长连时连接 Server占用资源大
      - 任何人不经过鉴权都可以上传, 日志存在被攻击可能,脏数据需要防范
  - Web socket 长连
    - 具体方式
      - APP 启动立即建立 Web scoket 长连接
      - 日志直接通过 Web socket 长连实时发送
      - 日志字段直接明文通过 长联放松
      - 可用 JSON 方式发送
    - 优点
      - 长连接实时
      - 数据无限制
      - 长连时,可以鉴权,防止第三方攻击
      - 公用字段可以在 header 中 共用
    - 缺点
      - 要依赖长连接, 长连接中断导致日志无法上传, 需要重新建立长连接
      - Client 依然需要失败 持久化 重传机制
      - Server 端维护成本较高.
- 日志的测试
  - 研发人员要有日志是功能 一部分的认识
  - 因为日志是功能一部分, 所以日志必须被测试, 测试不通过,不能上线,不能发版
  - 从数据驱动角度来说, 如果一个功能没有日志作为数据支撑, 无法评估效果, 功能的价值将得不到验证
  - QA 帮忙测试日志正确性
  - 自动化测试
    - 建立自动化测试脚本, 检查对应场景的必要字段, 检查是否有缺失, 是否有字段异常值
  - 人工检查
    - 建立方便人工检查的工具,
    - 点击一次发送一次
    - 展示页面, 格式化日志, 方便测试人员 安字段检查
    - 第一个版本需要全部字段测试, 检查每个字段是否符合预期
    - 后续更新需要建立重要 场景的回归测试 case
      - 曝光日志
      - 打开详情页
      - 视频的播放等
  - 数据校验
    - 入库后统计角度 统计分析日志的分布是否符合常理
      - 如人数, 播放时长是否符合预期等